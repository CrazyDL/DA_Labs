\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\textheight=23cm

\begin{document}

\section*{Лабораторная работа №\,5 по курсу дискретного анализа: Суффиксные деревья}

Выполнил студент группы 08-208 МАИ \textit{Левштанов Денис}.

\subsection*{Условие}

\begin{enumerate}
\item Необходимо реализовать алгоритм Укконена построения суффиксного дерева за линейное время. Построив такое дерево для некоторых из входных строк, необходимо воспользоваться полученным суффиксным деревом для решения своего варианта задания.

Алфавит строк: строчные буквы латинского алфавита (т.е., от a до z).
\item Поиск в известном тексте неизвестных заранее образцов
\end{enumerate}

\subsection*{Метод решения}
\par Считывается первая строка входных данных, добавляется к ней терминальный символ и строится суффиксное дерево по алгоритму Укконена. Затем производится поиск поступающих на вход слов в дереве. При этом в дереве воспроизводиться путь равный строке, если это удалось, то из текущей вершины обходятся все листы и выводятся их номера в порядке возрастания.

\subsection*{Описание программы}

\begin{enumerate}
\item ТSuffixTree.h(Объявление дерева и функций):
\par map<char, TNode*> childs; - переходы
\par TNode* suffLink; - суффиксная ссылка
\par int start; - индекс начала строки
\par int *end; - указатель на индекс конца строки
\par int suffixIndex; - позиция в суффикса в тексте
\item ТNode.cpp(Описание функций объявленных в TNode.h)
\par void BuildSuffixTree(); -Построить суффиксное дерево
\par void ExtendSuffixTree(int pos); - выполнение фазы добавления в дерево
\par void DeleteSuffixTree(TNode* node); - удаление дерева
\par void Search(string\& pat, int patNum); - поиск в тесте всех вхождений образца
\par void CountIndex(TNode* node, vector<int>\& vec); - посчитать индексы всех листьев, исходящих из данной вершины
\par int EdgeLength(TNode *node); - длинна дуги
\item main.cpp(Считывание данных, управление программой)
\end{enumerate}

\subsection*{Дневник отладки}

Программа не проходила тест №10 по нехватке памяти, решилось всё заменой массива переходов из узла на ассоциативный массив(map). 

\subsection*{Тест производительности}
Во всех рассматриваемых тестах одинаковые строки для поиска, но во втором исходный текст в 3 раза больше первого, а в третьем в 9 раз больше.
\begin{enumerate}
	\item Time of working: 0.582
	\item Time of working: 1.452
	\item Time of working: 0.177
	
\end{enumerate}
\subsection*{Выводы}
Самый универсальный алгоритм для различного рода задач, связанных с поиск в строке, и при этом самый эффективный - это алгоритм Укконена. Он основывается на наивном алгоритме построения дереве с кубической сложностью, но с помощью различных улучшений работает за линейную сложность. из-за большого количества модификаций наивного алгоритма, алгоритм Укконена становится сложен для понимания, однако остается самым лучшим из существующих.

\end{document}

