\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\textheight=23cm

\begin{document}

\section*{Лабораторная работа №\,7 по курсу дискретного анализа: Динамическое программирование}

Выполнил студент группы 08-208 МАИ \textit{Левштанов Денис}.

\subsection*{Условие}

\begin{enumerate}
\item При помощи метода динамического программирования разработать алгоритм решения задачи, определяемой своим вариантом; оценить время выполнения алгоритма и объем затрачиваемой оперативной памяти. Перед выполнением задания необходимо обосновать применимость метода динамического программирования.

Разработать программу на языке C или C++, реализующую построенный алгоритм. 
\item Обход матрицы

Задана матрица натуральных чисел A размерности n*m. Из текущей клетки можно перейти в любую из 3-х соседних, стоящих в строке с номером на единицу больше, при этом за каждый проход через клетку (i, j) взымается штраф $A_{i,j}$. Необходимо пройти из какой-нибудь клетки верхней строки до любой клетки нижней, набрав при проходе по клеткам минимальный штраф.

\end{enumerate}

\subsection*{Метод решения}
\par Считывается размерность матрицы, и сама матрица. Начиная со второй строки для каждого её элемента высчитывается наименьший штраф путем взятия минимума из трех предыдущих шагов. После обхода всех матрицы ищется минимальный элемент последней строки и выводится как ответ. Затем начиная с него восстанавливается путь, по которому это значение было получено.

\subsection*{Описание программы}

\begin{enumerate}
\item main.h(Считывание данных, управление программой):
\par size\_t n, m - размерность матрицы
\par int64\_t** arr - двумерный массив с которой происходит работа
\par int64\_t minWeight - минимальное значение в текущей строке
\par int64\_t minIndex - индекс минимального значения
\par int64\_t* path - массив, в котором хранится путь
\end{enumerate}

\subsection*{Дневник отладки}

Программа не проходила 11 тест из-за переполнения 32-битного int, решено использованием типа int64\_t.

\subsection*{Тест производительности}

\begin{enumerate}
	\item Time of working 100*100: 0.005
	\item Time of working 500*500: 0.132 \\
	(В 25 раз больше элементов, время работы дольше в 26,4 раза)
	\item Time of working 1000*1000: 0.56 \\
	 (В 4 раза больше элементов, время работы дольше в 4,2 раза)
	
\end{enumerate}
\subsection*{Выводы}
\par Задача может быть решена напрямую с использованием рекурсии, но в этом случаем сложность будет экспоненциальна (O($m*3^n$)), так как некоторые значения высчитываются много раз, что неприемлемо долго. Можно заметить, что для получения значения на текущем этапе нужно знать значения трех элементов с предыдущего этапа, то есть эту программу можно разбить на меньшие задачи, а это значит, что здесь применимо динамическое программирование. 
\par Мы можем искать значения ячеек начиная со второй строки, так как значения первой строки нам известно. Тем самым мы продвигаемся вниз по матрице и высчитываем каждый элемент только один раз и для хранения всех значений мы используем исходную матрицу. Тем самым временная сложность и объем затрачиваемой памяти равны О(m*n). Если нам еще нужно получить путь, то дополнительно требуется массив размером n и один обход от последней строки к первой, который занимает О(n) времени. В итоге общая сложность - О(m*n + n).

\end{document}

