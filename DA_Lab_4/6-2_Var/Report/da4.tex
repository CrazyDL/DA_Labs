\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\textheight=23cm

\begin{document}

\section*{Лабораторная работа №\,4 по курсу дискретного анализа: Поиск образца в строке}

Выполнил студент группы 08-208 МАИ \textit{Левштанов Денис}.

\subsection*{Условие}

\begin{enumerate}
\item Необходимо реализовать один из стандартных алгоритмов поиска образцов для указанного алфавита.
\item Поиск одного образца-маски: в образце может встречаться «джокер», равный любому другому символу. При реализации следует разбить образец на несколько, не содержащих «джокеров», найти все вхождения при помощcи алгоритма Ахо-Корасик и проверить их относительное месторасположение.
\end{enumerate}

\subsection*{Метод решения}
\par Считывается первая строка входных данных - образец, делится по джокерам на подобразцы, и составляется из них бор. В каждой вершине бора содержатся: ссылки перехода в формате map<Значение, ссылка на следующую вершину>, суфиксная ссылка, ссылка выхода, является ли вершина концом слова, позиции в главном образце, оканчивающихся в этой вершине подобразцов.
\par После разбора всего образца, происходит <<прошивка>>  бора, сначала <<прошиваются>> корень и следующие за ним вершины, затем следующие уровни по очереди.
\par Потом считывается весь текст в вектор <символ, <строка, позиция>> и отправляется на поиск.
В котором создается вектор равный размеру текста и заполняется нулями, и при нахождении какого-либо образца в этом веторе элемент под индексом [текущая позиция в тексте - позиция подобразца в образце] увеличивался на единицу.
В итоге образец считается найденным в позиции i, если в масиве на позиции i, число равно количеству образцов.

\subsection*{Описание программы}

\begin{enumerate}
\item ТNode.h(Объявление узла и функций):
\par map<uint32\_t, TNode*> child; - переходы
\par TNode* suffLink; - суфиксная ссылка
\par TNode* exitLink; - ссылка выхода
\par bool leaf; - является ли вершина концом образца
\par vector<size\_t> patSize; - позиции в главном образце, оканчивающихся в этой вершине подобразцов
\item ТNode.cpp(Описание функций объявленных в TNode.h)
\par void addPattern(TNode* root, vector<uint32\_t>\& pat, size\_t patSize); - добавление подобразца в бор
\par void processTrie(TNode* root, size\_t maxLen); - "прошивка" бора
\par void Search(TNode* root, vector< pair<int32\_t, pair<size\_t, size\_t> > > text, size\_t patLen, size\_t patCount); - поиск в тесте всех вхождений образца
\item main.cpp(Считывание данных, управление программой)
\end{enumerate}

\subsection*{Дневник отладки}

Программа не проходила тест №11 из-за ошибки в алгоритме прошивки и тесты №12, 17 из-за ошибки в алгоритме поиска, решилось всё правкой алгоритмов. 

\subsection*{Тест производительности}
\begin{enumerate}
	\item Образец длинной 1000 символов 1 подобразцов, 100 000 символов в тексте:  \\ Time of working: 1.05
	\item  Образец длинной 1000 символов 1 подобразцов, 500 000 символов в тексте: \\ Time of working: 9.991
	\item Образец длинной 500 символов 50 подобразцов, 500 000 символов в тексте: \\ Time of working: 2.595
	\item Образец длинной 500 символов 50 подобразцов, 5 000 000 символов в тексте: \\ Time of working: 34.081
	


	
\end{enumerate}
\subsection*{Выводы}
Алгоритм Ахо-Корасика позволяет искать сразу несколько образцов в строке за линейную сложность, из-за чего этот алгоритм часто используется: от утилиты grep до антивирусов.
Время работы также зависит от организации данных. Если таблицу переходов бора хранить как индексный массив — расход памяти O(na), вычислительная сложность O(na + H + k), где H — длина текста, n — общая длина всех слов в словаре, a — размер алфавита, k — общая длина всех совпадений. Если таблицу переходов автомата хранить как красно-чёрное дерево — расход памяти снижается до O(n), однако вычислительная сложность поднимается до O((H + n) log a + k).

\end{document}

